## 常见问题

①Top K问题：分治+Trie树/Hash_map+小顶堆。采用Hash(x)%M将原文件分割成小文件，如果小文件太大则继续Hash分割，直至可以放入内存。

②重复问题：BitMap位图 或 Bloom Filter布隆过滤器 或 Hash_set集合。每个元素对应一个bit处理。

③排序问题：外排序 或 BitMap位图。分割文件+文件内排序+文件之间归并。

 

## Top K问题

### 1. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词

**①分治：顺序读文件，对每个词x取Hash(x)%2000，按照该值存到2000个小文件中。每个文件是500k左右。如果有文件超过了1M则继续分割。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结 点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。O(N)**

**②Trie树/Hash_map：字符串用Trie树最好。对每个小文件，统计其中出现的词频。O(N)\*(平均字符长度),长度一般是常数，也就是O(N).** 

**③小顶堆：用容量为100的小顶堆，以频率为value值插入，取每个文件现频率最大的100个词，把这100个词及相应的频率存入文件。最差O（N）\*lg(100)，也就是O（N）.**注：2,3步骤合起来需要一轮磁盘存取过程。存入文件的个数可以缩减一下，因为主要开销在磁盘读取上，减少文件读取次数，可以在每个文件存取最大容量的字符数量，比如这道题1*（M/16字节字符串长度+频率（int）8字节）的数存到一个文件中。比如20000个词存在一个文件中，可以缩减到10个文件。这样最后一步只需要读取10次就可以了。

**④归并：将得到的10个文件里面的数进行归并，取前100个词。**注：我觉得其实不需要多路归并，因为只需要找top100的数，归并排序首先是nlgn的复杂度，第二是频繁的磁盘存取，这里最好是还是**在内存建立容量为100的小顶堆，依次读文件，遍历每个文件中的元素更新小顶堆，这样只需10次存取，并且时间复杂度是nlog100,也就是O（n）的。**

注释：为什么说用Trie树好，我之前一直没想明白，因为网上说Trie树是空间换时间，而这道题是空间敏感呀的。总结了一下，其实是两点我没想明白：

1.字符串会通过一个hash算法（BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，可以自己看一下，基本就是按位来进行hash的）映射为一个正整数然后对应到hash表中的一个位置，表中记录的value值是次数，这样统计次数只需要将字符串hash一下找到对应位置把次数+1就行了。如果这样的话hash中是不是不用存储字符串本身？如果不存储字符串本身，那应该是比较省空间的。而且效率的话因为Tire树找到一个字符串也是要按位置比较一遍，所以效率差不多呀。但是，其实**字符串的hash是要存储字符串本身的，不管是开放地址法还是散列表法，**都无法做到不冲突。除非桶个数是字符串的所有情况26^16，那是肯定空间不够的，因此hash表中**必须存着字符串的值，也就是key值。**字符串本身，那么hash在空间上肯定是定比不过Trie树的，因为Trie树对公共前缀只存储一次。

2.为什么说Trie树是空间换时间呢，我觉得网上这么说不甚合理，这句话其实是相对于二叉查找树来说的，之所以效率高，是因为二叉查找树每次查找都要比较大小，并且因为度为2，查找深度很大，比较次数也多，因此效率差。而Trie树是按位进行hash的，比如26个字母组成的字符串，每次找对应位的字符-‘a’就是位置了。而且度是26，查找深度就是字符串位数，查找起来效率自然就很快。但是为啥说是空间换时间，是因为字符串的Trie树若想存储所有的可能字符串，比如16位，一个点要对应下一位26种情况，也就是26个分支，**也得26^16个位置**，所以空间是很大的。但是Trie树的话可以采用依次插入的，**不需要每个点记录26个点，而是只存在有值的分支**，Trie树节点只要存频率次数，插入的流程就是挨个位子找分支，没有就新建，有就次数+1就行了。因此空间上很省，因为重复前缀就统计一次，而效率很高，O(length)。



### 2. 海量日志数据，提取出某日访问百度次数最多的那个IP。

**注：跟上一题一致，甚至更简单，不需要考虑trie树**

**①分治：IP是32位，共有232个IP。访问该日的日志，将IP取出来，采用Hash，比如模1000，把所有IP存入1000个小文件。**

**②Hash_map：统计每个小文件中出现频率最大的IP，记录其频率。**

**③小顶堆：这里用一个变量即可。在这1000个小文件各自最大频率的IP中，然后直接找出频率最大的IP。**

​	首先将这一天访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法， 比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大 的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。 
或者如下阐述： 
算法思想：分而治之+Hash 
1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 
2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 
3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址； 
4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；



### 3.请你统计最热门的10个查询串，要求使用的内存不能超过1G。**

搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。 
假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。 
典型的Top K算法，Hash表算法。 
给出的最终算法是： 
第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计； 
第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。 
即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别 和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）。 
或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。



### 4. 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。注：主要不同点在于分布式

**分析：虽然数据已经是分布的，但是如果直接求各自的Top10然后合并的话，可能忽略一种情况，即有一个数据在每台机器的频率都是第11，但是总数可能属于Top10。所以应该先把100台机器中相同的数据整合到相同的机器，然后再求各自的Top10并合并。**

**①分治：顺序读每台机器上的数据，按照Hash(x)%100重新分布到100台机器内。接下来变成了单机的topk问题。单台机器内的文件如果太大，可以继续Hash分割成小文件。**

**②Hash_map：统计每台机器上数据的频率。**

**③小顶堆：采用容量为10的小顶堆，统计每台机器上的Top10。然后把这100台机器上的TOP10组合起来，共1000个数据，再用小顶堆求出TOP10。**

 

### 5. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。 注：文件大小不需要分割文件

**①分治：一万行不算多，不用分割文件。**

**②Trie树：统计每个词出现的次数，时间复杂度是O(n\*le)  (le表示单词的平准长度)。**

**③小顶堆：容量为10的小顶堆，找出词频最多的前10个词，时间复杂度是O(n\*lg10)  (lg10表示堆的高度)。**

**总的时间复杂度是 O(n\*le)与O(n*lg10)中较大的那一个。**

 

### 6. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解

**比上一题多一次分割。分割成可以一次读入内存的大小。**

**①分治：顺序读文件，将文件Hash分割成小文件，求小文件里的词频。**

**②③同上。**

方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度）。然后是找出出现最频繁的前10 个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一 个。 


### 7.100w个数中找出最大的100个数

**方法1：用容量为100的小顶堆查找。复杂度为O(100w \* lg100)。小根堆是最好的方法。**

**方法2：采用快速排序的思想，每次分割之后只考虑比标兵值大的那一部分，直到大的部分在比100多且不能分割的时候，采用传统排序算法排序，取前100个。复杂度为O(100w\*100)。**

**方法3：局部淘汰法。取前100个元素并排序，然后依次扫描剩余的元素，插入到排好序的序列中，并淘汰最小值。复杂度为O(100w \* lg100)  (lg100为二分查找的复杂度)。**

 方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。 
方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。 
方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的 要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。



## 重复问题：

### 1. 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

**分析：每个文件的大小约为5G×64=320G，远远大于内存大小。考虑采取分而治之的方法。**

**方法1：**

**①分治：遍历文件a，对每个url求Hash%1000，根据值将url分别存储到1000个小文件中，每个小文件约为300M。文件b采用同样hash策略分到1000个小文件中。上述两组小文件中，只有相同编号的小文件才可能有相同元素。**

**②Hash_set：读取a组中一个小文件的url存储到hash_set中，然后遍历b组中相同编号小文件的每个url，查看是否在刚才构建的hash_set中。如果存在，则存到输出文件里。**

**方法2：**

**如果允许有一定的错误率，可以使用Bloom filter，使用位数组，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否在Bloom filter中。如果是，那么该url应该是共同的url（注意会有一定的错误率）。**

注： bloom filter被用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素不一定在集合中；但如果检测结果为否，该元素一定不在集合中。主要思路是：将一个元素映射到一个 m 长度的阵列上，使用 k 个哈希 函数对应 k 个点，如果所有点都是 1 的话，那么元素在集合内，如果有 0 的话，元素则不在集合内。 错误率：如何根据输入元素个数n，确定位数组m的大小及hash函数个数k，k=(ln2)*(m/n)时错误率最小，为f = (1 – e-kn/m)k 。



### 2. 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。

**分析：2.5亿个整数大概是954MB，也不是很大。当然可以更节省内存。整数一共2^32个数.每个数用2bit的话，需要1GB。也就是**

**方法1：**

**采用2-Bitmap，每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义。共需内存60MB左右。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完后，查看Bitmap，把对应位是01的整数输出。**

注：感觉这个方法不对呀，bitmap要统计所有的整数值，2*3^32是需要1GB内存呀，不是60MB, 954MB都存不下怎么存1GB?? 得到结论，bitmap统计整数存在性起码得有1G的内存。也就是说少于**268435456个数不如直接hash，消耗的内存反而更小！**

**方案2：**

**分治法，Hash分割成小文件处理。注意hash保证了每个文件中的元素一定不会在其他文件中存在。利用Hash_set，在小文件中找出不重复的整数，再进行归并。**

**方案3：**

**或者，我觉得可以将整个整数域划的bitmap根据内存大小分成可以几个文件，比如划分四个文件，这样的话0-1\*2^30在一个范围，，……，3*2^30-4*2^30在一个文件中，内存只要保证250M大小即可。整数需要放在对应的bitmap里面的对应位置，这里位置使用的是相对偏移量（value-首元素大小）。跟方案2相比分割的 方法不一样，以及每个小文件可以使用bitmap方法，所以更快一些。只是不知道有没有这种分割。**

### 3.一个文件包含40亿个整数，找出不包含的一个整数。分别用1GB内存和10MB内存处理。

**1GB内存：** 

**①Bitmap：对于32位的整数，共有232个，每个数对应一个bit，共需0.5GB内存。遍历文件，将每个数对应的bit位置1。最后查找0bit位即可。**

**10MB内存： 10MB = 8 × 107bit**

**①分治：将所有整数分段，每1M个数对应一个小文件，共4000个小文件。注意计算机能表示的所有整数有4G个。**

**②Hash_set：对每个小文件，遍历并加入Hash_set，最后如果set的size小于1M，则有不存在的数。利用Bitmap查找该数。**

注：计算机能表示的整数个数一共有4G个，整数域hash分割成10M一个文件，，一共分割成400个小文件，每个小文件判断不存在的数，再把这些数全都归并起来。**磁盘IO次数越少越好！！所以不明白为啥1M对应一个小文件，而不取最大的10M。**

 

### 4. 有10亿个URL，每个URL对应一个非常大的网页，怎样检测重复的网页？

**分析：不同的URL可能对应相同的网页，所以要对网页求Hash。1G个URL+哈希值，总量为几十G，单机内存无法处理。**

**①分治：根据Hash%1000，将URL和网页的哈希值分割到1000个小文件中，注意：重复的网页必定在同一个小文件中。**

**②Hash_set：顺序读取每个文件，将Hash值加入集合，如果已存在则为重复网页。** 



### **5.怎么在海量数据中找出重复次数最多的一个？**

方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。

 

### **6.上千万或上亿数据（有重复），统计其中出现次数最多的N个数据。**

方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。



### 7.腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？

我的第一反应时快速排序+二分查找。以下是其它更好的方法： 
方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 
dizengrong： 
方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下： 
又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中； 
这里我们把40亿个数中的每一个用32位的二进制来表示 
假设这40亿个数开始放在一个文件中。 
然后将这40亿个数分成两类: 
1.最高位为0 
2.最高位为1 
并将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（这相当于折半了）； 
与要查找的数的最高位比较并接着进入相应的文件再查找 
再然后把这个文件为又分成两类: 
1.次最高位为0 
2.次最高位为1 
并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿（这相当于折半了）； 
与要查找的数的次最高位比较并接着进入相应的文件再查找。 
……. 
以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。 
附：这里，再简单介绍下，位图方法： 
使用位图法判断整形数组是否存在重复 
判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。 
位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上 1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这 种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效 率还能提高一倍。



## 排序问题：

### 1. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求按照query的频度排序。

**方法1：** 

**①分治：顺序读10个文件，按照Hash(query)%10的结果将query写入到另外10个文件。新生成的每个文件大小为1G左右(假设hash函数是随机的)。**

**②Hash_map：找一台内存为2G左右的机器，用Hash_map(query, query_count)来统计次数。**

**③内排序：利用快速/堆/归并排序，按照次数进行排序。将排序好的query和对应的query_count输出到文件中，得到10个排好序的文件。**

**④多路归并：将这10个文件进行归并排序。**

**方案2：**

**一般query的总量是有限的，只是重复的次数比较多。对于所有的query，一次性就可能加入到内存。这样就可以采用Trie树/Hash_map等直接统计每个query出现的次数，然后按次数做快速/堆/归并排序就可以了**

**方案3：**

**与方案1类似，在做完Hash分割后，将多个文件采用分布式的架构来处理（比如MapReduce），最后再进行合并。**



### 2. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到这N^2个数的中位数？

**方法1： 32位的整数一共有232个**

**①分治：把0到232-1的整数划分成N段，每段包含232/N个整数。扫描每个机器上的N个数，把属于第一段的数放到第一个机器上，属于第二段的数放到第二个机器上，依此类推。 (如果有数据扎堆的现象，导致数据规模并未缩小，则继续分割)**

**②找中位数的机器：依次统计每个机器上数的个数并累加，直到找到第k个机器，加上其次数则累加值大于或等于N2/2，不加则累加值小于N2/2。**

**③找中位数：设累加值为x，那么中位数排在第k台机器所有数中第N2/2-x位。对这台机器的数排序，并找出第N2/2-x个数，即为所求的中位数。**

**复杂度是O(N2)。**

**方法2：**

**①内排序：先对每台机器上的数进行排序。**

**②多路归并：将这N台机器上的数归并起来得到最终的排序。找到第N2/2个数即是中位数。**

**复杂度是O(N2\*lgN)。**



## 总结

对海量数据的处理方法进行了一个一般性的总结，当然 这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。

### 一、Bloom filter 

适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集 
基本原理及要点： 
对于原理来说很简单，位数组+k个独立hash函数。将 hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不 支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。 
还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数 个数。当hash函数个数k=(ln2)*(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n*lg(1/E)才能表示任意n个元素的集 合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该>=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。 
举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。 
注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。 
扩展： 
Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。 
问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？ 
根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340 亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些 urlip是一一对应的，就可以转换成ip，则大大简单了。

### 二、Hashing 

适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存 
基本原理及要点： 
hash函数选择，针对字符串，整数，排列，具体相应的hash方法。 
碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。 
扩展： 
d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同 时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个 位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key 存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。 
问题实例： 
1).海量日志数据，提取出某日访问百度次数最多的那个IP。 
IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。

### 三、bit-map 

适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下 
基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码 
扩展：bloom filter可以看做是对bit-map的扩展 
问题实例： 
1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。 
8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 
2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 
将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。 

### 四、堆 

适用范围：海量数据前n大，并且n比较小，堆可以放入内存 
基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前 元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较 小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。 
扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。 
问题实例： 
1)100w个数中找最大的前100个数。 
用一个100个元素大小的最小堆即可。

### 五、双层桶划分—-其实本质上就是【分而治之】的思想，重在“分”的技巧上！ 

适用范围：第k大，中位数，不重复或重复的数字 
基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。 
扩展： 
问题实例： 
1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 
有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。 
2).5亿个int找它们的中位数。 
这个例子比上面那个更明显。首先我们 将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第 几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。 
实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受 的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里 的数的个数只有2^20，就可以直接利用direct addr table进行统计了。

### 六、数据库索引 

适用范围：大数据量的增删改查 
基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。

### 七、倒排索引(Inverted index) 

适用范围：搜索引擎，关键字查询 
基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。 
以英文为例，下面是要被索引的文本： 
T0 = “it is what it is” 
T1 = “what is it” 
T2 = “it is a banana” 
我们就能得到下面的反向文件索引： 
“a”: {2} 
“banana”: {2} 
“is”: {0, 1, 2} 
“it”: {0, 1, 2} 
“what”: {0, 1} 
检索的条件”what”,”is”和”it”将对应集合的交集。 
正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序 频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档 指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。 
扩展： 
问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。

### 八、外排序 

适用范围：大数据的排序，去重 
基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树 
扩展： 
问题实例： 
1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。 
这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。

### 九、trie树 

适用范围：数据量大，重复多，但是数据种类小可以放入内存 
基本原理及要点：实现方式，节点孩子的表示方式 
扩展：压缩实现。 
问题实例： 
1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。 
2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？ 
3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。

### 十、分布式处理 MapReduce 

适用范围：数据量大，但是数据种类小可以放入内存 
基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。 
扩展： 
问题实例： 
1).The canonical example application of MapReduce is a process to count the appearances of 
each different word in a set of documents: 
2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。 
3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？ 

### 经典问题分析 

​	上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。 
	可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序 
所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入 内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当 然这样导致维护次数增加，不如完全统计后在求前N大效率高。 
	如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。 
	当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程， 首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子， 
	最好可以让数据划分后可以一次读入内存，这样不同的机子负责处 理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据， 然后汇总，选出所有的数据中出现次数最多的前N个数据.

